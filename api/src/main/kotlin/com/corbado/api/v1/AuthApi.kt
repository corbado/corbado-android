/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.corbado.api.v1

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.corbado.api.models.BlockType
import com.corbado.api.models.EventCreateReq
import com.corbado.api.models.IdentifierUpdateReq
import com.corbado.api.models.IdentifierVerifyFinishReq
import com.corbado.api.models.IdentifierVerifyStartReq
import com.corbado.api.models.LoginInitReq
import com.corbado.api.models.PasskeyAppendFinishReq
import com.corbado.api.models.PasskeyAppendStartReq
import com.corbado.api.models.PasskeyLoginFinishReq
import com.corbado.api.models.PasskeyLoginStartReq
import com.corbado.api.models.PasskeyMediationFinishReq
import com.corbado.api.models.ProcessInitReq
import com.corbado.api.models.ProcessInitRsp
import com.corbado.api.models.ProcessResponse
import com.corbado.api.models.SignupInitReq
import com.corbado.api.models.SocialVerifyStartReq

import com.squareup.moshi.Json

import com.corbado.api.infrastructure.ApiClient
import com.corbado.api.infrastructure.ApiResponse
import com.corbado.api.infrastructure.ClientException
import com.corbado.api.infrastructure.ClientError
import com.corbado.api.infrastructure.ServerException
import com.corbado.api.infrastructure.ServerError
import com.corbado.api.infrastructure.MultiValueMap
import com.corbado.api.infrastructure.PartConfig
import com.corbado.api.infrastructure.RequestConfig
import com.corbado.api.infrastructure.RequestMethod
import com.corbado.api.infrastructure.ResponseType
import com.corbado.api.infrastructure.Success
import com.corbado.api.infrastructure.toMultiValue

class AuthApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://<project ID>.frontendapi.corbado.io")
        }
    }

    /**
     * POST /v2/auth/block/skip
     * 
     * tbd
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun blockSkip() : ProcessResponse {
        val localVarResponse = blockSkipWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/block/skip
     * 
     * tbd
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun blockSkipWithHttpInfo() : ApiResponse<ProcessResponse?> {
        val localVariableConfig = blockSkipRequestConfig()

        return request<Unit, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation blockSkip
     *
     * @return RequestConfig
     */
    fun blockSkipRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/block/skip",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/events
     * 
     * Creates a new user generated complete event.
     * @param eventCreateReq 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventCreate(eventCreateReq: EventCreateReq) : Unit {
        val localVarResponse = eventCreateWithHttpInfo(eventCreateReq = eventCreateReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/events
     * 
     * Creates a new user generated complete event.
     * @param eventCreateReq 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventCreateWithHttpInfo(eventCreateReq: EventCreateReq) : ApiResponse<Unit?> {
        val localVariableConfig = eventCreateRequestConfig(eventCreateReq = eventCreateReq)

        return request<EventCreateReq, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventCreate
     *
     * @param eventCreateReq 
     * @return RequestConfig
     */
    fun eventCreateRequestConfig(eventCreateReq: EventCreateReq) : RequestConfig<EventCreateReq> {
        val localVariableBody = eventCreateReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/identifier/update
     * 
     * tbd
     * @param identifierUpdateReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun identifierUpdate(identifierUpdateReq: IdentifierUpdateReq) : ProcessResponse {
        val localVarResponse = identifierUpdateWithHttpInfo(identifierUpdateReq = identifierUpdateReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/identifier/update
     * 
     * tbd
     * @param identifierUpdateReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun identifierUpdateWithHttpInfo(identifierUpdateReq: IdentifierUpdateReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = identifierUpdateRequestConfig(identifierUpdateReq = identifierUpdateReq)

        return request<IdentifierUpdateReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation identifierUpdate
     *
     * @param identifierUpdateReq 
     * @return RequestConfig
     */
    fun identifierUpdateRequestConfig(identifierUpdateReq: IdentifierUpdateReq) : RequestConfig<IdentifierUpdateReq> {
        val localVariableBody = identifierUpdateReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/identifier/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/identifier/verify/finish
     * 
     * tbd
     * @param identifierVerifyFinishReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun identifierVerifyFinish(identifierVerifyFinishReq: IdentifierVerifyFinishReq) : ProcessResponse {
        val localVarResponse = identifierVerifyFinishWithHttpInfo(identifierVerifyFinishReq = identifierVerifyFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/identifier/verify/finish
     * 
     * tbd
     * @param identifierVerifyFinishReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun identifierVerifyFinishWithHttpInfo(identifierVerifyFinishReq: IdentifierVerifyFinishReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = identifierVerifyFinishRequestConfig(identifierVerifyFinishReq = identifierVerifyFinishReq)

        return request<IdentifierVerifyFinishReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation identifierVerifyFinish
     *
     * @param identifierVerifyFinishReq 
     * @return RequestConfig
     */
    fun identifierVerifyFinishRequestConfig(identifierVerifyFinishReq: IdentifierVerifyFinishReq) : RequestConfig<IdentifierVerifyFinishReq> {
        val localVariableBody = identifierVerifyFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/identifier/verify/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/identifier/verify/start
     * 
     * tbd
     * @param identifierVerifyStartReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun identifierVerifyStart(identifierVerifyStartReq: IdentifierVerifyStartReq) : ProcessResponse {
        val localVarResponse = identifierVerifyStartWithHttpInfo(identifierVerifyStartReq = identifierVerifyStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/identifier/verify/start
     * 
     * tbd
     * @param identifierVerifyStartReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun identifierVerifyStartWithHttpInfo(identifierVerifyStartReq: IdentifierVerifyStartReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = identifierVerifyStartRequestConfig(identifierVerifyStartReq = identifierVerifyStartReq)

        return request<IdentifierVerifyStartReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation identifierVerifyStart
     *
     * @param identifierVerifyStartReq 
     * @return RequestConfig
     */
    fun identifierVerifyStartRequestConfig(identifierVerifyStartReq: IdentifierVerifyStartReq) : RequestConfig<IdentifierVerifyStartReq> {
        val localVariableBody = identifierVerifyStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/identifier/verify/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/auth/identifier/verify/status
     * 
     * tbd
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun identifierVerifyStatus() : ProcessResponse {
        val localVarResponse = identifierVerifyStatusWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/auth/identifier/verify/status
     * 
     * tbd
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun identifierVerifyStatusWithHttpInfo() : ApiResponse<ProcessResponse?> {
        val localVariableConfig = identifierVerifyStatusRequestConfig()

        return request<Unit, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation identifierVerifyStatus
     *
     * @return RequestConfig
     */
    fun identifierVerifyStatusRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/auth/identifier/verify/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/login/init
     * 
     * tbd
     * @param loginInitReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun loginInit(loginInitReq: LoginInitReq) : ProcessResponse {
        val localVarResponse = loginInitWithHttpInfo(loginInitReq = loginInitReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/login/init
     * 
     * tbd
     * @param loginInitReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun loginInitWithHttpInfo(loginInitReq: LoginInitReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = loginInitRequestConfig(loginInitReq = loginInitReq)

        return request<LoginInitReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation loginInit
     *
     * @param loginInitReq 
     * @return RequestConfig
     */
    fun loginInitRequestConfig(loginInitReq: LoginInitReq) : RequestConfig<LoginInitReq> {
        val localVariableBody = loginInitReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/login/init",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/passkey/append/finish
     * 
     * tbd
     * @param passkeyAppendFinishReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyAppendFinish(passkeyAppendFinishReq: PasskeyAppendFinishReq) : ProcessResponse {
        val localVarResponse = passkeyAppendFinishWithHttpInfo(passkeyAppendFinishReq = passkeyAppendFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/passkey/append/finish
     * 
     * tbd
     * @param passkeyAppendFinishReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyAppendFinishWithHttpInfo(passkeyAppendFinishReq: PasskeyAppendFinishReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = passkeyAppendFinishRequestConfig(passkeyAppendFinishReq = passkeyAppendFinishReq)

        return request<PasskeyAppendFinishReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyAppendFinish
     *
     * @param passkeyAppendFinishReq 
     * @return RequestConfig
     */
    fun passkeyAppendFinishRequestConfig(passkeyAppendFinishReq: PasskeyAppendFinishReq) : RequestConfig<PasskeyAppendFinishReq> {
        val localVariableBody = passkeyAppendFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/passkey/append/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/passkey/append/start
     * 
     * tbd
     * @param passkeyAppendStartReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyAppendStart(passkeyAppendStartReq: PasskeyAppendStartReq) : ProcessResponse {
        val localVarResponse = passkeyAppendStartWithHttpInfo(passkeyAppendStartReq = passkeyAppendStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/passkey/append/start
     * 
     * tbd
     * @param passkeyAppendStartReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyAppendStartWithHttpInfo(passkeyAppendStartReq: PasskeyAppendStartReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = passkeyAppendStartRequestConfig(passkeyAppendStartReq = passkeyAppendStartReq)

        return request<PasskeyAppendStartReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyAppendStart
     *
     * @param passkeyAppendStartReq 
     * @return RequestConfig
     */
    fun passkeyAppendStartRequestConfig(passkeyAppendStartReq: PasskeyAppendStartReq) : RequestConfig<PasskeyAppendStartReq> {
        val localVariableBody = passkeyAppendStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/passkey/append/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/passkey/login/finish
     * 
     * tbd
     * @param passkeyLoginFinishReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyLoginFinish(passkeyLoginFinishReq: PasskeyLoginFinishReq) : ProcessResponse {
        val localVarResponse = passkeyLoginFinishWithHttpInfo(passkeyLoginFinishReq = passkeyLoginFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/passkey/login/finish
     * 
     * tbd
     * @param passkeyLoginFinishReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyLoginFinishWithHttpInfo(passkeyLoginFinishReq: PasskeyLoginFinishReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = passkeyLoginFinishRequestConfig(passkeyLoginFinishReq = passkeyLoginFinishReq)

        return request<PasskeyLoginFinishReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyLoginFinish
     *
     * @param passkeyLoginFinishReq 
     * @return RequestConfig
     */
    fun passkeyLoginFinishRequestConfig(passkeyLoginFinishReq: PasskeyLoginFinishReq) : RequestConfig<PasskeyLoginFinishReq> {
        val localVariableBody = passkeyLoginFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/passkey/login/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/passkey/login/start
     * 
     * tbd
     * @param passkeyLoginStartReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyLoginStart(passkeyLoginStartReq: PasskeyLoginStartReq) : ProcessResponse {
        val localVarResponse = passkeyLoginStartWithHttpInfo(passkeyLoginStartReq = passkeyLoginStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/passkey/login/start
     * 
     * tbd
     * @param passkeyLoginStartReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyLoginStartWithHttpInfo(passkeyLoginStartReq: PasskeyLoginStartReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = passkeyLoginStartRequestConfig(passkeyLoginStartReq = passkeyLoginStartReq)

        return request<PasskeyLoginStartReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyLoginStart
     *
     * @param passkeyLoginStartReq 
     * @return RequestConfig
     */
    fun passkeyLoginStartRequestConfig(passkeyLoginStartReq: PasskeyLoginStartReq) : RequestConfig<PasskeyLoginStartReq> {
        val localVariableBody = passkeyLoginStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/passkey/login/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/passkey/mediation/finish
     * 
     * tbd
     * @param passkeyMediationFinishReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun passkeyMediationFinish(passkeyMediationFinishReq: PasskeyMediationFinishReq) : ProcessResponse {
        val localVarResponse = passkeyMediationFinishWithHttpInfo(passkeyMediationFinishReq = passkeyMediationFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/passkey/mediation/finish
     * 
     * tbd
     * @param passkeyMediationFinishReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun passkeyMediationFinishWithHttpInfo(passkeyMediationFinishReq: PasskeyMediationFinishReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = passkeyMediationFinishRequestConfig(passkeyMediationFinishReq = passkeyMediationFinishReq)

        return request<PasskeyMediationFinishReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation passkeyMediationFinish
     *
     * @param passkeyMediationFinishReq 
     * @return RequestConfig
     */
    fun passkeyMediationFinishRequestConfig(passkeyMediationFinishReq: PasskeyMediationFinishReq) : RequestConfig<PasskeyMediationFinishReq> {
        val localVariableBody = passkeyMediationFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/passkey/mediation/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/process/complete
     * 
     * tbd
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun processComplete() : ProcessResponse {
        val localVarResponse = processCompleteWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/process/complete
     * 
     * tbd
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun processCompleteWithHttpInfo() : ApiResponse<ProcessResponse?> {
        val localVariableConfig = processCompleteRequestConfig()

        return request<Unit, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation processComplete
     *
     * @return RequestConfig
     */
    fun processCompleteRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/process/complete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/auth/process
     * 
     * tbd
     * @param preferredBlock  (optional)
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun processGet(preferredBlock: BlockType? = null) : ProcessResponse {
        val localVarResponse = processGetWithHttpInfo(preferredBlock = preferredBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/auth/process
     * 
     * tbd
     * @param preferredBlock  (optional)
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun processGetWithHttpInfo(preferredBlock: BlockType?) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = processGetRequestConfig(preferredBlock = preferredBlock)

        return request<Unit, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation processGet
     *
     * @param preferredBlock  (optional)
     * @return RequestConfig
     */
    fun processGetRequestConfig(preferredBlock: BlockType?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (preferredBlock != null) {
                    put("preferredBlock", listOf(preferredBlock.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/auth/process",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/process/init
     * 
     * tbd
     * @param processInitReq 
     * @return ProcessInitRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun processInit(processInitReq: ProcessInitReq) : ProcessInitRsp {
        val localVarResponse = processInitWithHttpInfo(processInitReq = processInitReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessInitRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/process/init
     * 
     * tbd
     * @param processInitReq 
     * @return ApiResponse<ProcessInitRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun processInitWithHttpInfo(processInitReq: ProcessInitReq) : ApiResponse<ProcessInitRsp?> {
        val localVariableConfig = processInitRequestConfig(processInitReq = processInitReq)

        return request<ProcessInitReq, ProcessInitRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation processInit
     *
     * @param processInitReq 
     * @return RequestConfig
     */
    fun processInitRequestConfig(processInitReq: ProcessInitReq) : RequestConfig<ProcessInitReq> {
        val localVariableBody = processInitReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/process/init",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/process/reset
     * 
     * tbd
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun processReset() : ProcessResponse {
        val localVarResponse = processResetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/process/reset
     * 
     * tbd
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun processResetWithHttpInfo() : ApiResponse<ProcessResponse?> {
        val localVariableConfig = processResetRequestConfig()

        return request<Unit, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation processReset
     *
     * @return RequestConfig
     */
    fun processResetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/process/reset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/signup/init
     * 
     * tbd
     * @param signupInitReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun signupInit(signupInitReq: SignupInitReq) : ProcessResponse {
        val localVarResponse = signupInitWithHttpInfo(signupInitReq = signupInitReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/signup/init
     * 
     * tbd
     * @param signupInitReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun signupInitWithHttpInfo(signupInitReq: SignupInitReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = signupInitRequestConfig(signupInitReq = signupInitReq)

        return request<SignupInitReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signupInit
     *
     * @param signupInitReq 
     * @return RequestConfig
     */
    fun signupInitRequestConfig(signupInitReq: SignupInitReq) : RequestConfig<SignupInitReq> {
        val localVariableBody = signupInitReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/signup/init",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/auth/social/verify/callback
     * 
     * tbd
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun socialVerifyCallback() : Unit {
        val localVarResponse = socialVerifyCallbackWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/auth/social/verify/callback
     * 
     * tbd
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun socialVerifyCallbackWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = socialVerifyCallbackRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation socialVerifyCallback
     *
     * @return RequestConfig
     */
    fun socialVerifyCallbackRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/auth/social/verify/callback",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/social/verify/finish
     * 
     * tbd
     * @param body 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun socialVerifyFinish(body: kotlin.Any) : ProcessResponse {
        val localVarResponse = socialVerifyFinishWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/social/verify/finish
     * 
     * tbd
     * @param body 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun socialVerifyFinishWithHttpInfo(body: kotlin.Any) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = socialVerifyFinishRequestConfig(body = body)

        return request<kotlin.Any, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation socialVerifyFinish
     *
     * @param body 
     * @return RequestConfig
     */
    fun socialVerifyFinishRequestConfig(body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/social/verify/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/auth/social/verify/start
     * 
     * tbd
     * @param socialVerifyStartReq 
     * @return ProcessResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun socialVerifyStart(socialVerifyStartReq: SocialVerifyStartReq) : ProcessResponse {
        val localVarResponse = socialVerifyStartWithHttpInfo(socialVerifyStartReq = socialVerifyStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProcessResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/auth/social/verify/start
     * 
     * tbd
     * @param socialVerifyStartReq 
     * @return ApiResponse<ProcessResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun socialVerifyStartWithHttpInfo(socialVerifyStartReq: SocialVerifyStartReq) : ApiResponse<ProcessResponse?> {
        val localVariableConfig = socialVerifyStartRequestConfig(socialVerifyStartReq = socialVerifyStartReq)

        return request<SocialVerifyStartReq, ProcessResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation socialVerifyStart
     *
     * @param socialVerifyStartReq 
     * @return RequestConfig
     */
    fun socialVerifyStartRequestConfig(socialVerifyStartReq: SocialVerifyStartReq) : RequestConfig<SocialVerifyStartReq> {
        val localVariableBody = socialVerifyStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/auth/social/verify/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
