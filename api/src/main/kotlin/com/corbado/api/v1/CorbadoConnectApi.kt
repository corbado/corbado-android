/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.corbado.api.v1

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.corbado.api.models.ConnectAppendFinishReq
import com.corbado.api.models.ConnectAppendFinishRsp
import com.corbado.api.models.ConnectAppendInitReq
import com.corbado.api.models.ConnectAppendInitRsp
import com.corbado.api.models.ConnectAppendStartReq
import com.corbado.api.models.ConnectAppendStartRsp
import com.corbado.api.models.ConnectEventCreateReq
import com.corbado.api.models.ConnectLoginFinishReq
import com.corbado.api.models.ConnectLoginFinishRsp
import com.corbado.api.models.ConnectLoginInitReq
import com.corbado.api.models.ConnectLoginInitRsp
import com.corbado.api.models.ConnectLoginStartReq
import com.corbado.api.models.ConnectLoginStartRsp
import com.corbado.api.models.ConnectManageDeleteReq
import com.corbado.api.models.ConnectManageDeleteRsp
import com.corbado.api.models.ConnectManageInitReq
import com.corbado.api.models.ConnectManageInitRsp
import com.corbado.api.models.ConnectManageListReq
import com.corbado.api.models.ConnectManageListRsp
import com.corbado.api.models.ConnectProcessClearReq
import com.corbado.api.models.ConnectProcessClearRsp

import com.squareup.moshi.Json

import com.corbado.api.infrastructure.ApiClient
import com.corbado.api.infrastructure.ApiResponse
import com.corbado.api.infrastructure.ClientException
import com.corbado.api.infrastructure.ClientError
import com.corbado.api.infrastructure.ServerException
import com.corbado.api.infrastructure.ServerError
import com.corbado.api.infrastructure.MultiValueMap
import com.corbado.api.infrastructure.PartConfig
import com.corbado.api.infrastructure.RequestConfig
import com.corbado.api.infrastructure.RequestMethod
import com.corbado.api.infrastructure.ResponseType
import com.corbado.api.infrastructure.Success
import com.corbado.api.infrastructure.toMultiValue

class CorbadoConnectApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://<project ID>.frontendapi.corbado.io")
        }
    }

    /**
     * POST /v2/connect/append/finish
     * 
     * Finishes an initialized connect passkey append process.
     * @param connectAppendFinishReq 
     * @return ConnectAppendFinishRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectAppendFinish(connectAppendFinishReq: ConnectAppendFinishReq) : ConnectAppendFinishRsp {
        val localVarResponse = connectAppendFinishWithHttpInfo(connectAppendFinishReq = connectAppendFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectAppendFinishRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/append/finish
     * 
     * Finishes an initialized connect passkey append process.
     * @param connectAppendFinishReq 
     * @return ApiResponse<ConnectAppendFinishRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectAppendFinishWithHttpInfo(connectAppendFinishReq: ConnectAppendFinishReq) : ApiResponse<ConnectAppendFinishRsp?> {
        val localVariableConfig = connectAppendFinishRequestConfig(connectAppendFinishReq = connectAppendFinishReq)

        return request<ConnectAppendFinishReq, ConnectAppendFinishRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectAppendFinish
     *
     * @param connectAppendFinishReq 
     * @return RequestConfig
     */
    fun connectAppendFinishRequestConfig(connectAppendFinishReq: ConnectAppendFinishReq) : RequestConfig<ConnectAppendFinishReq> {
        val localVariableBody = connectAppendFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/append/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/append/init
     * 
     * Initializes a connect process for passkey append.
     * @param connectAppendInitReq 
     * @return ConnectAppendInitRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectAppendInit(connectAppendInitReq: ConnectAppendInitReq) : ConnectAppendInitRsp {
        val localVarResponse = connectAppendInitWithHttpInfo(connectAppendInitReq = connectAppendInitReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectAppendInitRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/append/init
     * 
     * Initializes a connect process for passkey append.
     * @param connectAppendInitReq 
     * @return ApiResponse<ConnectAppendInitRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectAppendInitWithHttpInfo(connectAppendInitReq: ConnectAppendInitReq) : ApiResponse<ConnectAppendInitRsp?> {
        val localVariableConfig = connectAppendInitRequestConfig(connectAppendInitReq = connectAppendInitReq)

        return request<ConnectAppendInitReq, ConnectAppendInitRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectAppendInit
     *
     * @param connectAppendInitReq 
     * @return RequestConfig
     */
    fun connectAppendInitRequestConfig(connectAppendInitReq: ConnectAppendInitReq) : RequestConfig<ConnectAppendInitReq> {
        val localVariableBody = connectAppendInitReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/append/init",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/append/start
     * 
     * Starts an initialized connect passkey append process.
     * @param connectAppendStartReq 
     * @return ConnectAppendStartRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectAppendStart(connectAppendStartReq: ConnectAppendStartReq) : ConnectAppendStartRsp {
        val localVarResponse = connectAppendStartWithHttpInfo(connectAppendStartReq = connectAppendStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectAppendStartRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/append/start
     * 
     * Starts an initialized connect passkey append process.
     * @param connectAppendStartReq 
     * @return ApiResponse<ConnectAppendStartRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectAppendStartWithHttpInfo(connectAppendStartReq: ConnectAppendStartReq) : ApiResponse<ConnectAppendStartRsp?> {
        val localVariableConfig = connectAppendStartRequestConfig(connectAppendStartReq = connectAppendStartReq)

        return request<ConnectAppendStartReq, ConnectAppendStartRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectAppendStart
     *
     * @param connectAppendStartReq 
     * @return RequestConfig
     */
    fun connectAppendStartRequestConfig(connectAppendStartReq: ConnectAppendStartReq) : RequestConfig<ConnectAppendStartReq> {
        val localVariableBody = connectAppendStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/append/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/events
     * 
     * Creates a new user generated connect event.
     * @param connectEventCreateReq 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectEventCreate(connectEventCreateReq: ConnectEventCreateReq) : Unit {
        val localVarResponse = connectEventCreateWithHttpInfo(connectEventCreateReq = connectEventCreateReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/events
     * 
     * Creates a new user generated connect event.
     * @param connectEventCreateReq 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun connectEventCreateWithHttpInfo(connectEventCreateReq: ConnectEventCreateReq) : ApiResponse<Unit?> {
        val localVariableConfig = connectEventCreateRequestConfig(connectEventCreateReq = connectEventCreateReq)

        return request<ConnectEventCreateReq, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectEventCreate
     *
     * @param connectEventCreateReq 
     * @return RequestConfig
     */
    fun connectEventCreateRequestConfig(connectEventCreateReq: ConnectEventCreateReq) : RequestConfig<ConnectEventCreateReq> {
        val localVariableBody = connectEventCreateReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/login/finish
     * 
     * Finishes an initialized connect login process.
     * @param connectLoginFinishReq 
     * @return ConnectLoginFinishRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectLoginFinish(connectLoginFinishReq: ConnectLoginFinishReq) : ConnectLoginFinishRsp {
        val localVarResponse = connectLoginFinishWithHttpInfo(connectLoginFinishReq = connectLoginFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectLoginFinishRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/login/finish
     * 
     * Finishes an initialized connect login process.
     * @param connectLoginFinishReq 
     * @return ApiResponse<ConnectLoginFinishRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectLoginFinishWithHttpInfo(connectLoginFinishReq: ConnectLoginFinishReq) : ApiResponse<ConnectLoginFinishRsp?> {
        val localVariableConfig = connectLoginFinishRequestConfig(connectLoginFinishReq = connectLoginFinishReq)

        return request<ConnectLoginFinishReq, ConnectLoginFinishRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectLoginFinish
     *
     * @param connectLoginFinishReq 
     * @return RequestConfig
     */
    fun connectLoginFinishRequestConfig(connectLoginFinishReq: ConnectLoginFinishReq) : RequestConfig<ConnectLoginFinishReq> {
        val localVariableBody = connectLoginFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/login/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/login/init
     * 
     * Initializes a connect process for login.
     * @param connectLoginInitReq 
     * @return ConnectLoginInitRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectLoginInit(connectLoginInitReq: ConnectLoginInitReq) : ConnectLoginInitRsp {
        val localVarResponse = connectLoginInitWithHttpInfo(connectLoginInitReq = connectLoginInitReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectLoginInitRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/login/init
     * 
     * Initializes a connect process for login.
     * @param connectLoginInitReq 
     * @return ApiResponse<ConnectLoginInitRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectLoginInitWithHttpInfo(connectLoginInitReq: ConnectLoginInitReq) : ApiResponse<ConnectLoginInitRsp?> {
        val localVariableConfig = connectLoginInitRequestConfig(connectLoginInitReq = connectLoginInitReq)

        return request<ConnectLoginInitReq, ConnectLoginInitRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectLoginInit
     *
     * @param connectLoginInitReq 
     * @return RequestConfig
     */
    fun connectLoginInitRequestConfig(connectLoginInitReq: ConnectLoginInitReq) : RequestConfig<ConnectLoginInitReq> {
        val localVariableBody = connectLoginInitReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/login/init",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/login/start
     * 
     * Starts an initialized connect login process.
     * @param connectLoginStartReq 
     * @return ConnectLoginStartRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectLoginStart(connectLoginStartReq: ConnectLoginStartReq) : ConnectLoginStartRsp {
        val localVarResponse = connectLoginStartWithHttpInfo(connectLoginStartReq = connectLoginStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectLoginStartRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/login/start
     * 
     * Starts an initialized connect login process.
     * @param connectLoginStartReq 
     * @return ApiResponse<ConnectLoginStartRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectLoginStartWithHttpInfo(connectLoginStartReq: ConnectLoginStartReq) : ApiResponse<ConnectLoginStartRsp?> {
        val localVariableConfig = connectLoginStartRequestConfig(connectLoginStartReq = connectLoginStartReq)

        return request<ConnectLoginStartReq, ConnectLoginStartRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectLoginStart
     *
     * @param connectLoginStartReq 
     * @return RequestConfig
     */
    fun connectLoginStartRequestConfig(connectLoginStartReq: ConnectLoginStartReq) : RequestConfig<ConnectLoginStartReq> {
        val localVariableBody = connectLoginStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/login/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/manage/delete
     * 
     * Deletes a passkey for a user identified by a connect token
     * @param connectManageDeleteReq 
     * @return ConnectManageDeleteRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectManageDelete(connectManageDeleteReq: ConnectManageDeleteReq) : ConnectManageDeleteRsp {
        val localVarResponse = connectManageDeleteWithHttpInfo(connectManageDeleteReq = connectManageDeleteReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectManageDeleteRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/manage/delete
     * 
     * Deletes a passkey for a user identified by a connect token
     * @param connectManageDeleteReq 
     * @return ApiResponse<ConnectManageDeleteRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectManageDeleteWithHttpInfo(connectManageDeleteReq: ConnectManageDeleteReq) : ApiResponse<ConnectManageDeleteRsp?> {
        val localVariableConfig = connectManageDeleteRequestConfig(connectManageDeleteReq = connectManageDeleteReq)

        return request<ConnectManageDeleteReq, ConnectManageDeleteRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectManageDelete
     *
     * @param connectManageDeleteReq 
     * @return RequestConfig
     */
    fun connectManageDeleteRequestConfig(connectManageDeleteReq: ConnectManageDeleteReq) : RequestConfig<ConnectManageDeleteReq> {
        val localVariableBody = connectManageDeleteReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/manage/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/manage/init
     * 
     * Initializes a connect process for passkey management.
     * @param connectManageInitReq 
     * @return ConnectManageInitRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectManageInit(connectManageInitReq: ConnectManageInitReq) : ConnectManageInitRsp {
        val localVarResponse = connectManageInitWithHttpInfo(connectManageInitReq = connectManageInitReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectManageInitRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/manage/init
     * 
     * Initializes a connect process for passkey management.
     * @param connectManageInitReq 
     * @return ApiResponse<ConnectManageInitRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectManageInitWithHttpInfo(connectManageInitReq: ConnectManageInitReq) : ApiResponse<ConnectManageInitRsp?> {
        val localVariableConfig = connectManageInitRequestConfig(connectManageInitReq = connectManageInitReq)

        return request<ConnectManageInitReq, ConnectManageInitRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectManageInit
     *
     * @param connectManageInitReq 
     * @return RequestConfig
     */
    fun connectManageInitRequestConfig(connectManageInitReq: ConnectManageInitReq) : RequestConfig<ConnectManageInitReq> {
        val localVariableBody = connectManageInitReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/manage/init",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/manage/list
     * 
     * Lists all passkeys for a user identifier by a connect token.
     * @param connectManageListReq 
     * @return ConnectManageListRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectManageList(connectManageListReq: ConnectManageListReq) : ConnectManageListRsp {
        val localVarResponse = connectManageListWithHttpInfo(connectManageListReq = connectManageListReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectManageListRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/manage/list
     * 
     * Lists all passkeys for a user identifier by a connect token.
     * @param connectManageListReq 
     * @return ApiResponse<ConnectManageListRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectManageListWithHttpInfo(connectManageListReq: ConnectManageListReq) : ApiResponse<ConnectManageListRsp?> {
        val localVariableConfig = connectManageListRequestConfig(connectManageListReq = connectManageListReq)

        return request<ConnectManageListReq, ConnectManageListRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectManageList
     *
     * @param connectManageListReq 
     * @return RequestConfig
     */
    fun connectManageListRequestConfig(connectManageListReq: ConnectManageListReq) : RequestConfig<ConnectManageListReq> {
        val localVariableBody = connectManageListReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/manage/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/connect/process/clear
     * 
     * Remove process state for a connect process.
     * @param connectProcessClearReq 
     * @return ConnectProcessClearRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun connectProcessClear(connectProcessClearReq: ConnectProcessClearReq) : ConnectProcessClearRsp {
        val localVarResponse = connectProcessClearWithHttpInfo(connectProcessClearReq = connectProcessClearReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConnectProcessClearRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/connect/process/clear
     * 
     * Remove process state for a connect process.
     * @param connectProcessClearReq 
     * @return ApiResponse<ConnectProcessClearRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun connectProcessClearWithHttpInfo(connectProcessClearReq: ConnectProcessClearReq) : ApiResponse<ConnectProcessClearRsp?> {
        val localVariableConfig = connectProcessClearRequestConfig(connectProcessClearReq = connectProcessClearReq)

        return request<ConnectProcessClearReq, ConnectProcessClearRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation connectProcessClear
     *
     * @param connectProcessClearReq 
     * @return RequestConfig
     */
    fun connectProcessClearRequestConfig(connectProcessClearReq: ConnectProcessClearReq) : RequestConfig<ConnectProcessClearReq> {
        val localVariableBody = connectProcessClearReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/connect/process/clear",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
