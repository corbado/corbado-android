/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.corbado.api.v1

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.corbado.api.models.GenericRsp
import com.corbado.api.models.MeIdentifierCreateReq
import com.corbado.api.models.MeIdentifierDeleteReq
import com.corbado.api.models.MeIdentifierUpdateReq
import com.corbado.api.models.MeIdentifierVerifyFinishReq
import com.corbado.api.models.MeIdentifierVerifyStartReq
import com.corbado.api.models.MePasskeyDeleteRsp
import com.corbado.api.models.MePasskeyRsp
import com.corbado.api.models.MePasskeysAppendFinishReq
import com.corbado.api.models.MePasskeysAppendStartReq
import com.corbado.api.models.MePasskeysAppendStartRsp
import com.corbado.api.models.MeRefreshRsp
import com.corbado.api.models.MeRsp
import com.corbado.api.models.MeUpdateReq

import com.squareup.moshi.Json

import com.corbado.api.infrastructure.ApiClient
import com.corbado.api.infrastructure.ApiResponse
import com.corbado.api.infrastructure.ClientException
import com.corbado.api.infrastructure.ClientError
import com.corbado.api.infrastructure.ServerException
import com.corbado.api.infrastructure.ServerError
import com.corbado.api.infrastructure.MultiValueMap
import com.corbado.api.infrastructure.PartConfig
import com.corbado.api.infrastructure.RequestConfig
import com.corbado.api.infrastructure.RequestMethod
import com.corbado.api.infrastructure.ResponseType
import com.corbado.api.infrastructure.Success
import com.corbado.api.infrastructure.toMultiValue

class UsersApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://<project ID>.frontendapi.corbado.io")
        }
    }

    /**
     * DELETE /v2/me
     * 
     * Deletes current user
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserDelete() : GenericRsp {
        val localVarResponse = currentUserDeleteWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /v2/me
     * 
     * Deletes current user
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserDeleteWithHttpInfo() : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserDeleteRequestConfig()

        return request<Unit, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserDelete
     *
     * @return RequestConfig
     */
    fun currentUserDeleteRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v2/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/me
     * 
     * Gets current user
     * @return MeRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserGet() : MeRsp {
        val localVarResponse = currentUserGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MeRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/me
     * 
     * Gets current user
     * @return ApiResponse<MeRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserGetWithHttpInfo() : ApiResponse<MeRsp?> {
        val localVariableConfig = currentUserGetRequestConfig()

        return request<Unit, MeRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserGet
     *
     * @return RequestConfig
     */
    fun currentUserGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/identifier
     * 
     * Creates an identifier
     * @param meIdentifierCreateReq 
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserIdentifierCreate(meIdentifierCreateReq: MeIdentifierCreateReq) : GenericRsp {
        val localVarResponse = currentUserIdentifierCreateWithHttpInfo(meIdentifierCreateReq = meIdentifierCreateReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/identifier
     * 
     * Creates an identifier
     * @param meIdentifierCreateReq 
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserIdentifierCreateWithHttpInfo(meIdentifierCreateReq: MeIdentifierCreateReq) : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserIdentifierCreateRequestConfig(meIdentifierCreateReq = meIdentifierCreateReq)

        return request<MeIdentifierCreateReq, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserIdentifierCreate
     *
     * @param meIdentifierCreateReq 
     * @return RequestConfig
     */
    fun currentUserIdentifierCreateRequestConfig(meIdentifierCreateReq: MeIdentifierCreateReq) : RequestConfig<MeIdentifierCreateReq> {
        val localVariableBody = meIdentifierCreateReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/identifier",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /v2/me/identifier
     * 
     * Deletes an identifier
     * @param meIdentifierDeleteReq 
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserIdentifierDelete(meIdentifierDeleteReq: MeIdentifierDeleteReq) : GenericRsp {
        val localVarResponse = currentUserIdentifierDeleteWithHttpInfo(meIdentifierDeleteReq = meIdentifierDeleteReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /v2/me/identifier
     * 
     * Deletes an identifier
     * @param meIdentifierDeleteReq 
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserIdentifierDeleteWithHttpInfo(meIdentifierDeleteReq: MeIdentifierDeleteReq) : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserIdentifierDeleteRequestConfig(meIdentifierDeleteReq = meIdentifierDeleteReq)

        return request<MeIdentifierDeleteReq, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserIdentifierDelete
     *
     * @param meIdentifierDeleteReq 
     * @return RequestConfig
     */
    fun currentUserIdentifierDeleteRequestConfig(meIdentifierDeleteReq: MeIdentifierDeleteReq) : RequestConfig<MeIdentifierDeleteReq> {
        val localVariableBody = meIdentifierDeleteReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v2/me/identifier",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PATCH /v2/me/identifier
     * 
     * Modifies an identifier (only permitted for username; identifierID will change)
     * @param meIdentifierUpdateReq 
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserIdentifierUpdate(meIdentifierUpdateReq: MeIdentifierUpdateReq) : GenericRsp {
        val localVarResponse = currentUserIdentifierUpdateWithHttpInfo(meIdentifierUpdateReq = meIdentifierUpdateReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /v2/me/identifier
     * 
     * Modifies an identifier (only permitted for username; identifierID will change)
     * @param meIdentifierUpdateReq 
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserIdentifierUpdateWithHttpInfo(meIdentifierUpdateReq: MeIdentifierUpdateReq) : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserIdentifierUpdateRequestConfig(meIdentifierUpdateReq = meIdentifierUpdateReq)

        return request<MeIdentifierUpdateReq, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserIdentifierUpdate
     *
     * @param meIdentifierUpdateReq 
     * @return RequestConfig
     */
    fun currentUserIdentifierUpdateRequestConfig(meIdentifierUpdateReq: MeIdentifierUpdateReq) : RequestConfig<MeIdentifierUpdateReq> {
        val localVariableBody = meIdentifierUpdateReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/v2/me/identifier",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/identifier/verify/finish
     * 
     * Verifies challenge
     * @param meIdentifierVerifyFinishReq 
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserIdentifierVerifyFinish(meIdentifierVerifyFinishReq: MeIdentifierVerifyFinishReq) : GenericRsp {
        val localVarResponse = currentUserIdentifierVerifyFinishWithHttpInfo(meIdentifierVerifyFinishReq = meIdentifierVerifyFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/identifier/verify/finish
     * 
     * Verifies challenge
     * @param meIdentifierVerifyFinishReq 
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserIdentifierVerifyFinishWithHttpInfo(meIdentifierVerifyFinishReq: MeIdentifierVerifyFinishReq) : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserIdentifierVerifyFinishRequestConfig(meIdentifierVerifyFinishReq = meIdentifierVerifyFinishReq)

        return request<MeIdentifierVerifyFinishReq, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserIdentifierVerifyFinish
     *
     * @param meIdentifierVerifyFinishReq 
     * @return RequestConfig
     */
    fun currentUserIdentifierVerifyFinishRequestConfig(meIdentifierVerifyFinishReq: MeIdentifierVerifyFinishReq) : RequestConfig<MeIdentifierVerifyFinishReq> {
        val localVariableBody = meIdentifierVerifyFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/identifier/verify/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/identifier/verify/start
     * 
     * Creates challenge (only email otp and phone otp supported for now)
     * @param meIdentifierVerifyStartReq 
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserIdentifierVerifyStart(meIdentifierVerifyStartReq: MeIdentifierVerifyStartReq) : GenericRsp {
        val localVarResponse = currentUserIdentifierVerifyStartWithHttpInfo(meIdentifierVerifyStartReq = meIdentifierVerifyStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/identifier/verify/start
     * 
     * Creates challenge (only email otp and phone otp supported for now)
     * @param meIdentifierVerifyStartReq 
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserIdentifierVerifyStartWithHttpInfo(meIdentifierVerifyStartReq: MeIdentifierVerifyStartReq) : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserIdentifierVerifyStartRequestConfig(meIdentifierVerifyStartReq = meIdentifierVerifyStartReq)

        return request<MeIdentifierVerifyStartReq, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserIdentifierVerifyStart
     *
     * @param meIdentifierVerifyStartReq 
     * @return RequestConfig
     */
    fun currentUserIdentifierVerifyStartRequestConfig(meIdentifierVerifyStartReq: MeIdentifierVerifyStartReq) : RequestConfig<MeIdentifierVerifyStartReq> {
        val localVariableBody = meIdentifierVerifyStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/identifier/verify/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/passkeys/append/finish
     * 
     * Finishes passkey append for current user
     * @param mePasskeysAppendFinishReq 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserPasskeyAppendFinish(mePasskeysAppendFinishReq: MePasskeysAppendFinishReq) : Unit {
        val localVarResponse = currentUserPasskeyAppendFinishWithHttpInfo(mePasskeysAppendFinishReq = mePasskeysAppendFinishReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/passkeys/append/finish
     * 
     * Finishes passkey append for current user
     * @param mePasskeysAppendFinishReq 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserPasskeyAppendFinishWithHttpInfo(mePasskeysAppendFinishReq: MePasskeysAppendFinishReq) : ApiResponse<Unit?> {
        val localVariableConfig = currentUserPasskeyAppendFinishRequestConfig(mePasskeysAppendFinishReq = mePasskeysAppendFinishReq)

        return request<MePasskeysAppendFinishReq, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserPasskeyAppendFinish
     *
     * @param mePasskeysAppendFinishReq 
     * @return RequestConfig
     */
    fun currentUserPasskeyAppendFinishRequestConfig(mePasskeysAppendFinishReq: MePasskeysAppendFinishReq) : RequestConfig<MePasskeysAppendFinishReq> {
        val localVariableBody = mePasskeysAppendFinishReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/passkeys/append/finish",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/passkeys/append/start
     * 
     * Starts passkey append for current user
     * @param mePasskeysAppendStartReq 
     * @return MePasskeysAppendStartRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserPasskeyAppendStart(mePasskeysAppendStartReq: MePasskeysAppendStartReq) : MePasskeysAppendStartRsp {
        val localVarResponse = currentUserPasskeyAppendStartWithHttpInfo(mePasskeysAppendStartReq = mePasskeysAppendStartReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MePasskeysAppendStartRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/passkeys/append/start
     * 
     * Starts passkey append for current user
     * @param mePasskeysAppendStartReq 
     * @return ApiResponse<MePasskeysAppendStartRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserPasskeyAppendStartWithHttpInfo(mePasskeysAppendStartReq: MePasskeysAppendStartReq) : ApiResponse<MePasskeysAppendStartRsp?> {
        val localVariableConfig = currentUserPasskeyAppendStartRequestConfig(mePasskeysAppendStartReq = mePasskeysAppendStartReq)

        return request<MePasskeysAppendStartReq, MePasskeysAppendStartRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserPasskeyAppendStart
     *
     * @param mePasskeysAppendStartReq 
     * @return RequestConfig
     */
    fun currentUserPasskeyAppendStartRequestConfig(mePasskeysAppendStartReq: MePasskeysAppendStartReq) : RequestConfig<MePasskeysAppendStartReq> {
        val localVariableBody = mePasskeysAppendStartReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/passkeys/append/start",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /v2/me/passkeys/{credentialID}
     * 
     * Delete current user&#39;s passkeys
     * @param credentialID Credential ID from passkeys
     * @return MePasskeyDeleteRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserPasskeyDelete(credentialID: kotlin.String) : MePasskeyDeleteRsp {
        val localVarResponse = currentUserPasskeyDeleteWithHttpInfo(credentialID = credentialID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MePasskeyDeleteRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /v2/me/passkeys/{credentialID}
     * 
     * Delete current user&#39;s passkeys
     * @param credentialID Credential ID from passkeys
     * @return ApiResponse<MePasskeyDeleteRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserPasskeyDeleteWithHttpInfo(credentialID: kotlin.String) : ApiResponse<MePasskeyDeleteRsp?> {
        val localVariableConfig = currentUserPasskeyDeleteRequestConfig(credentialID = credentialID)

        return request<Unit, MePasskeyDeleteRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserPasskeyDelete
     *
     * @param credentialID Credential ID from passkeys
     * @return RequestConfig
     */
    fun currentUserPasskeyDeleteRequestConfig(credentialID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v2/me/passkeys/{credentialID}".replace("{"+"credentialID"+"}", encodeURIComponent(credentialID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/me/passkeys
     * 
     * Gets current user&#39;s passkeys
     * @return MePasskeyRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserPasskeyGet() : MePasskeyRsp {
        val localVarResponse = currentUserPasskeyGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MePasskeyRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/me/passkeys
     * 
     * Gets current user&#39;s passkeys
     * @return ApiResponse<MePasskeyRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserPasskeyGetWithHttpInfo() : ApiResponse<MePasskeyRsp?> {
        val localVariableConfig = currentUserPasskeyGetRequestConfig()

        return request<Unit, MePasskeyRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserPasskeyGet
     *
     * @return RequestConfig
     */
    fun currentUserPasskeyGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/me/passkeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/logout
     * 
     * Performs session logout
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserSessionLogout() : Unit {
        val localVarResponse = currentUserSessionLogoutWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/logout
     * 
     * Performs session logout
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserSessionLogoutWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = currentUserSessionLogoutRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserSessionLogout
     *
     * @return RequestConfig
     */
    fun currentUserSessionLogoutRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v2/me/refresh
     * 
     * Performs session refresh
     * @return MeRefreshRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserSessionRefresh() : MeRefreshRsp {
        val localVarResponse = currentUserSessionRefreshWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MeRefreshRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v2/me/refresh
     * 
     * Performs session refresh
     * @return ApiResponse<MeRefreshRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserSessionRefreshWithHttpInfo() : ApiResponse<MeRefreshRsp?> {
        val localVariableConfig = currentUserSessionRefreshRequestConfig()

        return request<Unit, MeRefreshRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserSessionRefresh
     *
     * @return RequestConfig
     */
    fun currentUserSessionRefreshRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/me/refresh",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PATCH /v2/me
     * 
     * Updates current user
     * @param meUpdateReq 
     * @return GenericRsp
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun currentUserUpdate(meUpdateReq: MeUpdateReq) : GenericRsp {
        val localVarResponse = currentUserUpdateWithHttpInfo(meUpdateReq = meUpdateReq)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericRsp
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /v2/me
     * 
     * Updates current user
     * @param meUpdateReq 
     * @return ApiResponse<GenericRsp?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun currentUserUpdateWithHttpInfo(meUpdateReq: MeUpdateReq) : ApiResponse<GenericRsp?> {
        val localVariableConfig = currentUserUpdateRequestConfig(meUpdateReq = meUpdateReq)

        return request<MeUpdateReq, GenericRsp>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation currentUserUpdate
     *
     * @param meUpdateReq 
     * @return RequestConfig
     */
    fun currentUserUpdateRequestConfig(meUpdateReq: MeUpdateReq) : RequestConfig<MeUpdateReq> {
        val localVariableBody = meUpdateReq
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/v2/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
